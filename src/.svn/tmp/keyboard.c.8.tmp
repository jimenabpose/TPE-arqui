#include "../include/defs.h"
#include "../include/cpu_info.h"
#include "../include/stdio.h"
#include "../include/console.h"

#define NADA 0xFF
#define ESCAPE -2
#define MAX_CODES 150
#define TRUE	1
#define FALSE	0
#define AUX 0
#define ECHO_CD 1
#define CLEAR_CD 2
#define SETTIME_CD 3
#define ACTSP_CD 4
#define DSPIMG_CD 5
#define CNF_CD 6
#define NO_CD 7
#define GBG_CD 8
#define MARIO_CD 9
#define CODE_CD 10

#define LONG_STR_TKN 100
#define LONG_STR_CMD 320

static char bufferIsFull(void);

static int shift = 1;

teclator tecl = {{0},0,0,0};

int bflag=FALSE;

/*Mapa de caracteres del teclado en ingl√©s.*/

unsigned char ScanCodesEn[MAX_CODES][2] =	{ 				
	
	{NADA,NADA},
	/*Escape*/	{ESCAPE,ESCAPE},

	{'!','1'},{'@','2'},{'#','3'},{'$','4'},{'%','5'},
	{'^','6'},{'&','7'},{'*','8'},{'(','9'}, {')','0'},{'_','-'},{'+','='},
	
	/*BACKSPACE*/	{'\b','\b'}, 
	/*TAB*/	{'\t','\t'},

	{'Q','q'},{'W','w'},{'E','e'},{'R','r'},{'T','t'},{'Y','y'},{'U','u'},
	{'I','i'},{'O','o'},{'P','p'},{'{','['},{'}',']'},

	/*Enter*/	{'\n','\n'},
	/*CTRL IZQ*/	{NADA,NADA},

	{'A','a'},{'S','s'},{'D','d'},{'F','f'},{'G','g'},{'H','h'},{'J','j'},
	{'K','k'},{'L','l'},{':',';'}, {'"','\''},{'~','`'},

	{NADA,NADA},{'|','\\'},{'Z','z'},{'X','x'},{'C','c'},{'V','v'},{'B','b'},
	{'N','n'},{'M','m'},{'<',','},{'>','.'},{'?','/'},
	
	/*Shift Derecho*/	{NADA,NADA},{'*','*'},
	/*ALT IZQ*/	{NADA,NADA},
	/*Espacio*/	{' ',' '},
	/*CAPSLOCK*/	{NADA,NADA},

	/*F1*/	{NADA,NADA},{NADA,NADA},{NADA,NADA},{NADA,NADA},{NADA,NADA},
		{NADA,NADA},{NADA,NADA},{NADA,NADA},{NADA,NADA},{NADA,NADA},

	/*NUM LOCK*/	{NADA,NADA},
	/*SCROLL LOCK*/	{NADA,NADA},
					
	/*Key Pad*/

	{'7','7'},{'8','8'},{'9','9'},{'-','-'},
	{'4','4'},{'5','5'},{'6','6'},{'+','+'},
	{'1','1'},{'2','2'},{'3','3'},{'0','0'},
	{'.','.'},{NADA,NADA},{'+','*'},{'+','*'},
				
	/*F11*/{NADA,NADA},
	{NADA,NADA},//088 F12
	{'+','*'},	//089
	{'+','*'}	//090
};

void int_09(int code) 
{
	if(code == 0x2A || code == 0x36)
		shift = 0;
    else if( code == 0x2A+0x80 || code == 0x36+0x80)
		shift = 1;
		
	else if((code >= 0x02 && code <= 0x0D) || (code >= 0x0F && code <= 0x1B)
		|| (code >= 0x1E && code <= 0x29) || (code >= 0x2B && code <= 0x35) 
		|| (code >= 0x2B && code <= 0x35) || code == 39){
		printf("%c",ScanCodesEn[code][shift]);	
	}


	
//	char *video = (char *) 0xb8000;
//	video[tickpos+10]=ScanCodesEn[code-1][2];
//
//	
//	tickpos = (tickpos + 10) % (80*40);
//	
	return;
}


/*
 * 
 * levanta un scancode del buffer de teclado 
 */
static unsigned char getScanCode(void)
{
    static unsigned char scancode = 0;
    scancode = tecl.read;
    tecl.read++;

    if( tecl.read == BUFFER_SIZE)
        tecl.read = 0;
    bflag = FALSE;
    
    return scancode;
}

/*
 * decide si hay data sin leer
 */
static char bufferHasNewData(void)
{
    return (((tecl.write == tecl.read) && bflag) || (tecl.write != tecl.read));
}

/*
 * Escribe un scancode al buffer de teclado, si el buffer esta lleno no hace nada.
 * 
 */
static void writeToBuffer(unsigned char scancode)
{
    if( !bufferIsFull() )
    {
        tecl.write = scancode;
        tecl.write++;

	/*
	* si se esta apuntando a un lugar fuera del buffer
	* volver al principio
	*/
        if( tecl.write == BUFFER_SIZE)
        {
            tecl.write = 0;
        }

        if( tecl.write == tecl.read )
            bflag = TRUE;
    }
}
/* 
 * retorna si el buffer esta lleno o no
 */
static char bufferIsFull(void)
{
    return ((tecl.write == tecl.read) && bflag);
}

/*
** recibe un comando
** y llama a la funcion que corresponda
*/

int
comandos(char s[2][LONG_STR_TKN])
{
	int cursorBkp;
	int arg_extra=0;

	if(s[0][0]==0)
		return NO_CD;
	else if(strcmp(s[0], "echo"))
	{
		puts(s[1]);
		flush();
		return ECHO_CD;
	}
	else if(strcmp(s[0], "clear"))
	{
		if(s[1][0]==0)
		{
			k_clear_screen();
			return CLEAR_CD;
		}
		else
			arg_extra=1;
	}
	
	else if(strcmp(s[0], "garbage"))
	{
		if(s[1][0]==0)
		{
			garbage();
			return GBG_CD;
		}
		else
			arg_extra=1;
	}
	
	else if(strcmp(s[0], "cpuid"))
	{
		if(s[1][0]==0)
		{
			puts("CPUID");
			flush();
			cpuid();
			/*return cpuid();*/
		}
		else
			arg_extra=1;
	}
	else if(strcmp(s[0], "ls"))
	{
		if(s[1][0]==0)
		{
			puts("dev      root     home");
			printChar('\n');
			puts("bin      mnt      boot" );
			printChar('\n');
			puts("usr      etc      media");
			return CODE_CD;
		}
		else
			arg_extra=1;
	}
	else if(strcmp(s[0], "help"))
	{
		if(s[1][0]==0)
		{
			puts("Johnelite\n");
			puts("echo [string arguments]");
			puts("clear");
			printChar('\n');
			puts("cpuid");
			printChar('\n');
			puts("clear");
			printChar('\n');
			puts("garbage");
			printChar('\n');
			puts("ls");
			printChar('\n');
			puts("help");
			printChar('\n');
			return CODE_CD;
		}
		else
			arg_extra=1;
	}

	if(arg_extra==0)
	{
		puts(s[0]);
		printChar(':');
		puts(" command not found");
		flush();
		return CNF_CD;
	}
	else
	{
		puts(s[0]);
		printChar(':');
		puts(" does not receive arguments");
		flush();
		return CNF_CD;
	}
}




