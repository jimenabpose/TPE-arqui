#include "../include/defs.h"
#include "../include/video.h"
#include "../include/stdio.h"
#include "../include/kasm.h"

#define	TOPE_FILAS	40
#define	TOPE_COLS	80


byte videoBuffer[V_BUFFER_LENGTH] = {0};
byte cleanBuffer[V_BUFFER_LENGTH] = {0};
byte screenBuffer[4160] = {};
byte blankScreenBuffer[4000] = {' ', 0x09, ' ', 0x09, ' ', 0x09};
static int vb_counter = 0;

int cursor = 0;
int tickpos = 0;

byte int_80(dword op, dword data, dword offset, dword fd)
{
	if(op == WRITE)
	{
		if (fd == FD_PANTALLA)
		{
			write_screen(data,offset);
			cursor = cursor + 2;
			return 0;
		}
	}
	else if(op == READ)
	{
		if (fd == FD_PANTALLA)
		{
			return read_screen();		
		} 
		else if (fd == FD_TECLADO)
		{
		printf("adsf");
			return next_char();
		}
	}
}

void write(int fd, const void* buffer, int count) {
	int i;
	int offset;
	byte data;

	for ( i = 0 ; i<count; i++) {
		offset = i + cursor;
		data = *((byte *)buffer+i);
		screenBuffer[offset] = data;
		_call_int_80(WRITE, fd, offset, data);
	}

	/*cursor+=count/2;*/

}

byte read(int fd, void* buffer, int count) {
	int i;
	byte * b = (byte *)buffer;
    	for ( i = 0 ; i<count; i++) {
        	b[i] = _call_int_80(READ, fd, i, 0);
        	if (b[i] == 0xFF) { 
            		break;
        	}
    	}
    
	return i;
}

/*
* puts
*
* Escribe el string str en pantalla.
* 
*/
void puts( const char * str ) {
    while (*str) {
        printChar(*str++);
    }
}


/*
* flush
*
* si queda algo en el buffer de put_char, lo imprime
* 
*/
void flush() {
    if (cursor + vb_counter >= 2000) {

        check_screen_scroll(vb_counter);

        write(FD_PANTALLA, videoBuffer, vb_counter);
        vb_counter = 0;
    } else {
        check_offset('4',vb_counter);
        write(FD_PANTALLA, videoBuffer, vb_counter);
        vb_counter = 0;
    }
}

void check_offset(char label, int count) {
    /*
    if (cursor*2 +count-1 >= 4000) {
                while (1) {
                    int H;
                    char * p = (char * ) 0xB8000;
                    for (H=0; H<2000;H++) {
                        if (H>=0 && H <160)
                            *(p+H*2+1)=RED_ALL;
                        else if (H>=160 && H <240)
                            *(p+H*2)=err_str[(H-160)];
                        else if (H>=240 && H <320)
                            *(p+H*2)=label;
                        else if (H>=320 && H <324)
                            *(p+H*2)= digit(H-320, cursor)+'0';
                        else if (H>=330 && H <334)
                            *(p+H*2)= digit(H-330, count)+'0';
                        else
                            *(p+H*2+1)=RED_ALL;
                            
                    }
                }
        }
*/
}

/*
* se fija si hay q scrollear la pantalla
* 
*/

void check_screen_scroll(int offset) {
    if (cursor + offset >= 4000) {
        page_roll(4000-cursor);
    }
    return;
}

/* 
* scrolea la pantalla para arriba 
*/

void page_roll(int backwards) {
	int i;
	cursor = 0;
	for(i=0;i<4000;i=i+2){
		write(FD_PANTALLA, screenBuffer+160+i,1);
	}	
  	cursor = 4000-160;
    return;
}

void
printf ( const char *format, ... )
{
	char **arg = (char **) &format;
	int c;
	char buf[20];
	
	_Cli();
	
	arg++;

	while ((c = *format++) != 0)
	{
		if (c != '%')
		{
			printChar(c);
		}
		else
		{
			char *p;
			c = *format++;

			switch (c)
			{
				case 'd':
				case 'u':
				case 'x':
					itoa (buf, c, *((int *) arg++));
					p = buf;
					goto string;
					break;

				case 's':
					p = *arg++;
					if (! p)
						p = "(null)";

				string:
					while (*p)
					printChar (*p++);
					break;

				default:
					printChar (*((int *) arg++));
					break;
			}
		}	
	}
	_Sti();
}

void
printChar( char ascii )
{

	check_screen_scroll(0);
	
	char *video = (char *) 0xb8000;
	
	/* Si es el backspace */
	if(ascii == '\x08')
	{
		video[tickpos-2]=' ';
		tickpos = (tickpos - 2) % (80*40);
	}
	
	/* Si es un tab */
	else if(ascii == '\t')
	{
		tickpos = (tickpos + 4) % (80*40);
	}
	
	/* Resto de los caracteres */
	
	else {
		write(FD_PANTALLA, &ascii, 1);
	}
	
//	videoBuffer[vb_counter] = ascii;
  //  vb_counter += 2 ;
	
	return;

}

void
print_new_line()
{
<<<<<<< .mine
	cursor = (cursor + 160 - (cursor % 160));
	printf("Johnelite> ");
=======
	
	cursor = (cursor + 160 - (cursor % 80));
	check_screen_scroll(0);
		
	/*printf("%d",cursor);
	int i;
	for(i = 0; i < 80 - (cursor/2); i++)
	{
		printf(" ");	
	}*/
	/*check_screen_scroll(0);*/
>>>>>>> .r61
}

void
print_enter()
{
	cursor = (cursor + 160 - (cursor % 160));
}

void
erase_a_character()
{
	char esp= ' ';
    cursor -= 2;
    write(FD_PANTALLA, &esp, 1);
    cursor -= 2;
}

void
initialize_screen()
{
	printf("Bienvenido a Johnelite");
	print_enter();
	printf("Si necesita ayuda tipee el comando ayuda");
	print_enter();
}

void
garbage()
{
	char c = 'a';
        int i;
        for (i = 0; i<2000; i++)
        {
		printChar(c++%50+'a');
		flush();
	}
}

#define K_BUFFER_LENGTH 1

byte keyboard_buffer[K_BUFFER_LENGTH] = {0};
int kb_counter = K_BUFFER_LENGTH;
int n_read = K_BUFFER_LENGTH;

byte get_char() {
    if ( kb_counter == n_read ) {
        do 
        {
		    n_read = read(FD_TECLADO, keyboard_buffer, K_BUFFER_LENGTH);
        }
        while (n_read == 0);
		    kb_counter = 0;
    }
    return keyboard_buffer[kb_counter++];
}
