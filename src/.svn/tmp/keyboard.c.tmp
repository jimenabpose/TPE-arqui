#include "../include/defs.h"

#define NADA 0
#define ESCAPE -2
#define MAX_CODES 150
#define BUFFER_SIZE 240
#define TRUE	1
#define FALSE	0

teclator tecl = {{0},0,0,0};

static unsigned char buffer[BUFFER_SIZE] = {0};

/* Buffer de teclado circular */
static unsigned char * bwrite = buffer;
static unsigned char * bread = buffer;
static char bflag = FALSE;

/*Mapa de caracteres del teclado en ingl√©s.*/

unsigned char ScanCodesEn[MAX_CODES][2] =	{ 				
	
	{NADA,NADA},/*Escape*/{ESCAPE,ESCAPE},

	{'!','1'},{'@','2'},{'#','3'},{'$','4'},{'%','5'},
	{'^','6'},{'&','7'},{'*','8'},{'(','9'}, {')','0'},{'_','-'},{'+','='},
	
	/*BACKSPACE*/ 	{'\b','\b'}, 
	/*TAB*/		{'\t','\t'},

	{'Q','q'},{'W','w'},{'E','e'},{'R','r'},{'T','t'},{'Y','y'},{'U','u'},
	{'I','i'},{'O','o'},{'P','p'},{'{','['},{'}',']'},

	/*Enter*/	{'\n','\n'},
	/*CTRL IZQ*/	{NADA,NADA},

	{'A','a'},{'S','s'},{'D','d'},{'F','f'},{'G','g'},{'H','h'},{'J','j'},
	{'K','k'},{'L','l'},{':',';'}, {'"','\''},{'~','`'},

	{NADA,NADA},{'|','\\'},{'Z','z'},{'X','x'},{'C','c'},{'V','v'},{'B','b'},
	{'N','n'},{'M','m'},{'<',','},{'>','.'},{'?','/'},
	
	/*Shift Derecho*/	{NADA,NADA},{'*','*'},
	/*ALT IZQ*/		{NADA,NADA},
	/*Espacio*/		{' ',' '},
	/*CAPSLOCK*/		{NADA,NADA},

	/*F1*/	{NADA,NADA},{NADA,NADA},{NADA,NADA},{NADA,NADA},{NADA,NADA},
		{NADA,NADA},{NADA,NADA},{NADA,NADA},{NADA,NADA},{NADA,NADA},

	/*NUM LOCK*/	{NADA,NADA},
	/*SCROLL LOCK*/	{NADA,NADA},
					
	/*Key Pad*/

	{'7','7'},{'8','8'},{'9','9'},{'-','-'},
	{'4','4'},{'5','5'},{'6','6'},{'+','+'},
	{'1','1'},{'2','2'},{'3','3'},{'0','0'},
	{'.','.'},{NADA,NADA},{'+','*'},{'+','*'},
				
	/*F11*/{NADA,NADA},
	{NADA,NADA},//088 F12
	{'+','*'},	//089
	{'+','*'}	//090
};

/*
 * Escribe un scancode al buffer de teclado, si el buffer esta lleno no hace nada.
 * 
 */
static void writeToBuffer(unsigned char scancode)
{
    if( !bufferIsFull() )
    {
        *bwrite = scancode;
        bwrite++;

        if( bwrite == (buffer + BUFFER_SIZE))
        {
            bwrite = buffer;
        }

        if( bwrite == bread )
            bflag = TRUE;
    }
}
/* 
 * retorna si el buffer esta lleno o no
 */
static char bufferIsFull(void)
{
    return ((bwrite == bread) && bflag);
}



